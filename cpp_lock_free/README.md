## 基础概念
- 无阻塞
- 无锁
- 无等待

## 无锁 stack 实现
对于`push`操作而言比较简单，使用 CAS 操作保证即可。
```c++
void push(T data) {
    node* new_node = new node(data);
    new_node->next = header;
    while(!header.compare_exchange_weak(new_node->next,new_node));
}
```

对于`pop`操作则复杂一点:  
一个线程删除节点时，其他线程可能仍然持有指向该节点的指针并尝试解引用它。这会导致未定义行为。为了解决这个问题，需要确保节点在删除之前没有被其他线程引用。

### 统一回收
内存管理与删除节点
为了确保在删除节点时没有其他线程引用，需要一种机制来管理节点的生命周期。主要思路是:
- 引用计数：使用 std::shared_ptr 来管理节点的数据，确保在没有线程引用数据时自动释放内存。
- 计数器：引入一个原子计数器，记录当前正在访问栈的线程数量。当没有线程访问栈时，可以安全地删除节点。

### 风险指针
删除一个节点可能会让其他引用线 程处于危险状态。其他线程持有已删除节点的指针对其进行解引用操作时，会出现未定义行为。基本观点就 是，当有线程去访问(其他线程)删除的对象时，会先对这个对象设置风险指针，而后通知其他线程——使用这 个指针是危险的行为。当这个对象不再需要，就可以清除风险指针。  
当线程想要删除一个对象，就必须检查系统中其他线程是否持有风险指针。当没有风险指针时，就可以安全删除对象。否则，就必须等待风险指针消失。这样，线程就需要周期性的检查要删除的对象是否能安全删除。

## 无锁队列
核心操作依然是 `push()` 和 `pop()`，但是操作的不是同一端。`push`操作是针对队尾的， `pop`操作是针对队头。
```bash
tail               header
 |                  |
 |                  |
 [] -> [] -> []  -> []
 |                  |
 |                  |
push()             pop()
```
需要保证: `一端的修改对另一端可见`。
### SPSC
单生产单消费