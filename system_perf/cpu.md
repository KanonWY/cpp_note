## CPU perf

htop/top/pidstat
```bash
sudo apt-get install sysstat
```

### pidstat的使用

#### 1、主要可以查看进程 CPU 的相关消耗和当前运行的核心

-I

```bash
> pidstat -I -p  3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)
10时56分43秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
10时56分43秒  1000   3398417    1.0%    0.4%    0.0%    0.0%    0.2%     6  remote_driving
```

user - 用户空间消耗

system - 内核空间消耗

guest - 表示在虚拟CPU上执行的时间的百分比，即进程在虚拟CPU上执行所占用的时间的百分比

wait - 表示等待I/O完成的时间的百分比，即进程等待I/O操作完成所占用的时间的百分比

%CPU - 表示进程在所有CPU上的总CPU时间的百分比，包括用户空间、内核空间和虚拟CPU时间。

CPU - 表示进程当前正在运行的CPU的编号

#### 2、查看指定进程优先级

-R

```bash
> pidstat -R -p 3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)

10时59分38秒   UID       PID prio policy  Command
10时59分38秒  1000   3398417    0 NORMAL  remote_driving
```

Prio:表示进程的调度优先级。数字越低表示优先级越高

policy: 进程调度策略

#### 3、查看进程栈大小

-s

```bash
pidstat -s -p 3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)

11时01分25秒   UID       PID StkSize  StkRef  Command
11时01分25秒  1000   3398417  136.0k    8.0k  remote_driving
```

**StkSize**

表示进程的栈大小，即进程的栈空间占用大小。这里的"k"表示单位为千字节

**StkRef**

表示进程的栈引用大小，即进程的栈空间的引用计数大小。同样，这里的"k"表示单位为千字节。

栈引用：

栈引用是指进程的栈空间的引用计数大小。在操作系统中，每个进程都有自己的栈空间，用于存储局部变量、函数调用信息和临时数据。栈引用跟踪着栈空间的引用计数，即有多少个指针指向该栈空间。

当栈空间被多个线程或者函数调用共享时，栈引用就会增加，因为有多个指针指向同一块栈空间。反之，当栈空间不再被任何指针引用时，栈引用会减少。

栈引用的主要作用是帮助操作系统管理进程的内存。当栈引用为零时，表示栈空间不再被任何进程或线程使用，操作系统可以回收该部分内存以供其他用途。因此，栈引用可以帮助操作系统更有效地管理内存资源，避免内存泄漏和不必要的内存占用。

#### 4、查看线程和文件描述符信息

-v

```bash
pidstat -v -p 3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)

11时05分46秒   UID       PID threads   fd-nr  Command
11时05分46秒  1000   3398417      17      30  remote_driving
```

threads: 线程数

Fd-nr:表示进程当前打开的文件描述符数目。文件描述符是进程与文件系统之间的接口，用于表示文件、套接字等I/O对象

#### 5、查看上下文切换

-w

```bash
 pidstat -w -p 3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)

11时08分45秒   UID       PID   cswch/s nvcswch/s  Command
11时08分45秒  1000   3398417      0.00      0.00  remote_driving
```

**cswch/s列**：

- `0.00`：表示每秒钟的上下文切换次数。在这里，`cswch`指的是上下文切换的总次数（包括进程切换和CPU中断切换），`s`表示每秒的单位。

**nvcswch/s列**：

- `0.00`：表示每秒钟的非自愿上下文切换次数。在这里，`nvcswch`指的是非自愿上下文切换的次数，即进程由于某种原因而被迫放弃CPU执行权，比如等待I/O完成或者时间片用完。

#### 6、报告页错误与内存使用

-r

```bash
pidstat -r -p 3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)

11时12分12秒   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
11时12分12秒  1000   3398417      0.01      0.02    1.1G    2.3M   0.0%  remote_driving
```

- **minflt/s**：每秒钟的次要页面错误数，即访问已在内存中的页面。
- **majflt/s**：每秒的主要页面错误数，即访问不在内存中的页面。
- **VSZ**：进程的虚拟内存大小，表示进程地址空间的总大小。
- **RSS**：进程的驻留集大小，即物理内存中实际使用的大小。
- **%MEM**：进程占用的物理内存占系统总内存的百分比。

实际使用的内存是 RSS（Resident Set Size）。RSS 表示进程当前实际占用的物理内存大小，即进程在 RAM 中的实际占用量。RSS 包括了进程使用的代码、数据以及共享库等占用的物理内存大小，相比之下，VSZ（Virtual Memory Size）表示进程当前使用的虚拟地址空间的大小，包括了进程的代码、数据、堆、栈等占用的虚拟内存大小，但不一定都会被加载到物理内存中。因此，VSZ 可能会比 RSS 大得多，尤其是对于使用大量动态分配内存的进程来说。进程实际使用的物理内存大小（RSS），因为它直接反映了进程在系统中的内存占用情况。

#### 7、io 统计

```bash
pidstat -d -p 3398417 --human
Linux 5.15.0-105-generic (sim) 	2024年05月21日 	_x86_64_	(8 CPU)

11时15分14秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
11时15分14秒  1000   3398417    842.9B     12.1k      0.0B       0  remote_driving
```

- **kB_rd/s**：每秒从磁盘读取的数据量（以KB为单位）。
- **kB_wr/s**：每秒向磁盘写入的数据量（以KB为单位）。
- **kB_ccwr/s**：每秒被回写到磁盘的数据量（以KB为单位）。这指的是已经存在于内存中但尚未写入磁盘的数据。
- **iodelay**：I/O 延迟，表示在处理 I/O 操作时产生的延迟次数。

io延迟

I/O延迟（iodelay）是指在进行I/O操作时发生的延迟次数。它表示了系统在处理I/O请求时所花费的时间，通常由于一些因素导致了I/O操作的延迟。以下是一些可能导致I/O延迟的情况：

1. **磁盘性能问题**：磁盘本身的性能问题，如磁盘速度慢、磁盘故障等，可能导致I/O操作的延迟。
2. **文件系统问题**：文件系统的性能问题，如文件系统碎片化、inode分配不足等，也可能导致I/O操作的延迟。
3. **系统负载过高**：系统负载过高时，可能导致I/O操作被排队等待处理，从而产生I/O延迟。
4. **磁盘缓存问题**：如果系统使用了磁盘缓存，而缓存命中率较低，导致需要频繁地从磁盘读取数据，也会增加I/O延迟。
5. **设备驱动程序问题**：设备驱动程序的问题可能导致I/O操作的延迟，例如驱动程序的bug、兼容性问题等。
6. **其他系统资源竞争**：其他系统资源的竞争，如内存、CPU等，也可能影响到I/O操作的延迟。

kB_ccwr/s 表示每秒被回写到磁盘的数据量，通常是指已经存在于内存中但尚未写入磁盘的数据。这些数据通常存在于操作系统的文件系统缓存中，等待被写入到磁盘中。

回写到磁盘的数据（write-back）发生在以下情况下：

1. **脏数据刷新**：当数据被修改后，被标记为“脏”（dirty），表示与磁盘上的数据不同步。操作系统通过一种称为回写机制（write-back）的方式，定期或根据需要将这些脏数据写回到磁盘中，以保持数据的一致性。
2. **LRU策略**：当文件系统缓存中的页被淘汰（evict）出缓存时，如果这些页是脏的，就需要将其写回到磁盘中。
3. **系统关闭**：在正常关机或系统异常崩溃时，为了确保数据的一致性，操作系统会将所有脏数据写回到磁盘中。
4. **同步写入**：某些应用程序在写入数据时会使用同步写入（synchronous write）方式，这会立即将数据写入磁盘，而不是先写入到文件系统缓存中。如果应用程序频繁进行同步写入，可能会导致大量的数据被回写到磁盘。
