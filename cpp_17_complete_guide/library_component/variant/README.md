## std::variant
std::variant<> 的动机源于对传统 C++ 联合（union）的一些缺点和局限性的改进。传统的 C++ 联合虽然能够存储多个可能类型中的一种，但存在以下问题：

- 对象类型未知：联合对象在任何时候都无法知道其当前保存的具体类型。
- 无法处理非平凡成员：对于非平凡的成员类型（如 std::string），使用联合会非常麻烦，需要特殊的实现。
- 不能继承：联合类型不能作为基类进行继承。

为了解决这些问题，C++ 标准库引入了 std::variant<>，这是一个封闭的判别联合（discriminated union），具有以下特性：
- 当前值类型已知：std::variant<> 总是知道当前持有值的类型。
- 支持任意指定类型的成员：std::variant<> 可以包含任意指定类型的成员。
- 可以继承：允许作为基类进行继承。
实际上，std::variant<> 持有的是不同类型的多个候选值中的一个。这些候选值通常具有不同的类型，但也可以有相同的类型，这在一些情况下（例如，表示不同语义含义的同一类型值）非常有用。

此外，std::variant<> 具有以下优点：
- 内存管理：只需要内部管理内存的最大尺寸和一些固定开销，不会分配堆内存。
- 非空保障：一般情况下，std::variant<> 不会为空，除非使用特定的替代方案来表示空值。但在极少数情况下（如由于分配新类型值时的异常），variant 可能会处于没有任何值的状态。
- 值语义：类似于 std::optional<> 和 std::any，std::variant<> 具有值语义，深拷贝时会创建一个独立的对象，包含当前候选值的副本。支持移动语义。  


通过这些特性，std::variant<> 提供了一种处理不同数据类型的新方式，避免了使用共同基类和指针（无论是原始指针还是智能指针）的需要，从而简化了多态和异构集合的处理。

